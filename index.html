<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YouTube Calm Sprite Overlay</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  overflow: hidden;
  font-family: Inter, system-ui, sans-serif;
}

/* ===== SPRITE CONTAINER ===== */
.sprite {
  position: absolute;
  transform: translate(-50%, -50%);
  pointer-events: none;
  image-rendering: pixelated;
}

/* ===== SPRITE IMAGE ===== */
.sprite img {
  height: 64px;
  transform-origin: center;
}

/* flip ONLY the image */
.sprite.flip img {
  transform: scaleX(-1);
}

/* ===== USERNAME ===== */
.name {
  position: absolute;
  top: -14px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  font-weight: 600;
  color: white;
  white-space: nowrap;
  text-shadow: 0 2px 4px rgba(0,0,0,0.7);
}
</style>
</head>

<body>

<script>
/* ===============================
   CONFIG (CALM & CLEAN)
================================ */
const GRAVITY = 0.6;
const WANDER_FORCE = 0.0006;
const DESPAWN_TIME = 2 * 60 * 1000; // 2 minutes

/* ===============================
   MATTER SETUP
================================ */
const { Engine, Runner, Bodies, World, Events, Body } = Matter;

const engine = Engine.create();
engine.world.gravity.y = GRAVITY;

const width = window.innerWidth;
const height = window.innerHeight;

/* ===============================
   WORLD BOUNDS
================================ */
World.add(engine.world, [
  Bodies.rectangle(width / 2, height - 8, width, 16, { isStatic: true }),
  Bodies.rectangle(-30, height / 2, 60, height, { isStatic: true }),
  Bodies.rectangle(width + 30, height / 2, 60, height, { isStatic: true })
]);

/* ===============================
   SPRITES
================================ */
const SPRITES = [
  'sprites/2b.gif',
  'sprites/goku.gif',
  'sprites/naruto.gif',
  'sprites/sasuke.gif',

  // new sprites
  'sprites/arm.gif',
  'sprites/cboy.gif',
  'sprites/iron.gif',
  'sprites/mage.gif',
  'sprites/skull.gif',
  'sprites/supri.gif',
  'sprites/wit.gif',
  'sprites/wiz.gif'
];

const characters = new Map();

/* ===============================
   SPAWN / UPDATE
================================ */
function spawnOrUpdate(username, message = '') {
  let body = characters.get(username);

  if (!body) {
    body = Bodies.rectangle(
      Math.random() * width,
      -80,                 // simple drop from above
      32,
      48,
      {
        friction: 0.3,
        frictionAir: 0.05,
        restitution: 0,
        collisionFilter: { group: -1 }, // pass through others
        render: { visible: false }
      }
    );

    body.plugin = {
      username,
      dir: Math.random() > 0.5 ? 1 : -1,
      nextChange: performance.now() + rand(4000, 8000),
      lastActive: performance.now()
    };

    const el = document.createElement('div');
    el.className = 'sprite';
    el.innerHTML = `
      <div class="name">${username}</div>
      <img src="${SPRITES[Math.floor(Math.random() * SPRITES.length)]}">
    `;

    document.body.appendChild(el);

    body.plugin.el = el;
    characters.set(username, body);
    World.add(engine.world, body);
  }

  body.plugin.lastActive = performance.now();
  handleCommand(body, message);
}

/* ===============================
   COMMANDS
================================ */
function handleCommand(body, msg) {
  msg = msg.toLowerCase();

  if (msg.includes('!jump')) {
    Body.applyForce(body, body.position, { x: 0, y: -0.02 });
  }

  if (msg.includes('!left')) body.plugin.dir = -1;
  if (msg.includes('!right')) body.plugin.dir = 1;

  if (msg.includes('!bye')) {
    removeCharacter(body);
  }
}

/* ===============================
   WANDER LOGIC
================================ */
Events.on(engine, 'beforeUpdate', () => {
  const now = performance.now();

  characters.forEach(body => {
    const p = body.plugin;

    if (now > p.nextChange) {
      p.dir = Math.random() > 0.5 ? 1 : -1;
      p.nextChange = now + rand(4000, 8000);
    }

    Body.applyForce(body, body.position, {
      x: p.dir * WANDER_FORCE,
      y: 0
    });

    if (now - p.lastActive > DESPAWN_TIME) {
      removeCharacter(body);
    }
  });
});

/* ===============================
   RENDER SYNC
================================ */
Events.on(engine, 'afterUpdate', () => {
  characters.forEach(body => {
    const el = body.plugin.el;

    el.style.left = body.position.x + 'px';
    el.style.top = body.position.y + 'px';

    // flip sprite ONLY, never the username
    if (body.plugin.dir === -1) {
      el.classList.add('flip');
    } else {
      el.classList.remove('flip');
    }
  });
});

/* ===============================
   REMOVE CHARACTER
================================ */
function removeCharacter(body) {
  World.remove(engine.world, body);
  body.plugin.el.remove();
  characters.delete(body.plugin.username);
}

/* ===============================
   DEMO (REPLACE WITH YT CHAT)
================================ */
const demoUsers = ['Dev', 'Alpha', 'Beta', 'Gamma', 'Delta'];
const demoCmds = ['', '', '!jump', '!left', '!right'];

setInterval(() => {
  const u = demoUsers[Math.floor(Math.random() * demoUsers.length)];
  const m = demoCmds[Math.floor(Math.random() * demoCmds.length)];
  spawnOrUpdate(u, m);
}, 3000);

function rand(min, max) {
  return Math.random() * (max - min) + min;
}

Runner.run(Runner.create(), engine);
</script>

</body>
</html>
