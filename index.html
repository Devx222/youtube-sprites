<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YouTube Calm Sprite Overlay</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0" />

<script src="https://cdn.jsdelivr.net/npm/matter-js@0.19.0/build/matter.min.js"></script>

<style>
html, body {
  margin: 0;
  padding: 0;
  background: transparent;
  overflow: hidden;
  font-family: Inter, system-ui, sans-serif;
}

.sprite {
  position: absolute;
  transform: translate(-50%, -50%);
  pointer-events: none;
  image-rendering: pixelated;
}

.sprite img {
  height: 64px;
  transform-origin: center;
}

.sprite.flip img {
  transform: scaleX(-1);
}

.name {
  position: absolute;
  top: -14px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 11px;
  font-weight: 600;
  color: white;
  white-space: nowrap;
  text-shadow: 0 2px 4px rgba(0,0,0,0.7);
}
</style>
</head>

<body>

<script>
/* ===============================
   CONFIG
================================ */
const GRAVITY = 0.6;
const WANDER_FORCE = 0.0006;
const DESPAWN_TIME = 2 * 60 * 1000; // 2 minutes

const { Engine, Runner, Bodies, World, Events, Body } = Matter;
const engine = Engine.create();
engine.world.gravity.y = GRAVITY;

const width = window.innerWidth;
const height = window.innerHeight;

/* ===============================
   WORLD BOUNDS
================================ */
World.add(engine.world, [
  Bodies.rectangle(width / 2, height - 8, width, 16, { isStatic: true }),
  Bodies.rectangle(-30, height / 2, 60, height, { isStatic: true }),
  Bodies.rectangle(width + 30, height / 2, 60, height, { isStatic: true })
]);

/* ===============================
   SPRITES
================================ */
const SPRITES = [
  'sprites/2b.gif',
  'sprites/goku.gif',
  'sprites/naruto.gif',
  'sprites/sasuke.gif',
  'sprites/arm.gif',
  'sprites/cboy.gif',
  'sprites/iron.gif',
  'sprites/mage.gif',
  'sprites/skull.gif',
  'sprites/supri.gif',
  'sprites/wit.gif',
  'sprites/wiz.gif'
];

const characters = new Map();

/* ===============================
   SPAWN / UPDATE
================================ */
function spawnOrUpdate(username, message = '') {
  let body = characters.get(username);

  if (!body) {
    body = Bodies.rectangle(
      Math.random() * width,
      -80,
      32,
      48,
      {
        friction: 0.3,
        frictionAir: 0.05,
        restitution: 0,
        collisionFilter: { group: -1 },
        render: { visible: false }
      }
    );

    body.plugin = {
      username,
      dir: Math.random() > 0.5 ? 1 : -1,
      nextChange: performance.now() + rand(4000, 8000),
      lastActive: performance.now()
    };

    const el = document.createElement('div');
    el.className = 'sprite';
    el.innerHTML = `
      <div class="name">${username}</div>
      <img src="${SPRITES[Math.floor(Math.random() * SPRITES.length)]}">
    `;

    document.body.appendChild(el);
    body.plugin.el = el;
    characters.set(username, body);
    World.add(engine.world, body);
  }

  body.plugin.lastActive = performance.now();
  handleCommand(body, message);
}

/* ===============================
   COMMANDS
================================ */
function handleCommand(body, msg) {
  msg = msg.toLowerCase();
  if (msg.includes('!jump')) Body.applyForce(body, body.position, { x: 0, y: -0.02 });
  if (msg.includes('!left')) body.plugin.dir = -1;
  if (msg.includes('!right')) body.plugin.dir = 1;
  if (msg.includes('!bye')) removeCharacter(body);
}

/* ===============================
   WANDER LOGIC
================================ */
Events.on(engine, 'beforeUpdate', () => {
  const now = performance.now();
  characters.forEach(body => {
    const p = body.plugin;
    if (now > p.nextChange) {
      p.dir = Math.random() > 0.5 ? 1 : -1;
      p.nextChange = now + rand(4000, 8000);
    }
    Body.applyForce(body, body.position, { x: p.dir * WANDER_FORCE, y: 0 });
    if (now - p.lastActive > DESPAWN_TIME) removeCharacter(body);
  });
});

/* ===============================
   RENDER SYNC
================================ */
Events.on(engine, 'afterUpdate', () => {
  characters.forEach(body => {
    const el = body.plugin.el;
    el.style.left = body.position.x + 'px';
    el.style.top = body.position.y + 'px';
    if (body.plugin.dir === -1) el.classList.add('flip'); 
    else el.classList.remove('flip');
  });
});

/* ===============================
   REMOVE CHARACTER
================================ */
function removeCharacter(body) {
  World.remove(engine.world, body);
  body.plugin.el.remove();
  characters.delete(body.plugin.username);
}

function rand(min, max) {
  return Math.random() * (max - min) + min;
}

Runner.run(Runner.create(), engine);

/* ===============================
   YOUTUBE CHAT INTEGRATION
================================ */
const API_KEY = 'AIzaSyDHwlSUcaFUCD9A38zBwFsNc3sMsOZs-2g';
const VIDEO_ID = 'ToosnvilqQ4';
let nextPageToken = '';

async function fetchChat() {
  try {
    // Get live chat ID if not already
    if (!window.liveChatId) {
      const res = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=liveStreamingDetails&id=${VIDEO_ID}&key=${API_KEY}`);
      const data = await res.json();
      window.liveChatId = data.items[0].liveStreamingDetails.activeLiveChatId;
      if (!window.liveChatId) {
        console.error('No live chat found for this video');
        setTimeout(fetchChat, 5000);
        return;
      }
    }

    const url = `https://www.googleapis.com/youtube/v3/liveChat/messages?liveChatId=${window.liveChatId}&part=snippet,authorDetails&pageToken=${nextPageToken}&key=${API_KEY}`;
    const chatRes = await fetch(url);
    const chatData = await chatRes.json();

    nextPageToken = chatData.nextPageToken || '';
    if (chatData.items) {
      chatData.items.forEach(item => {
        const username = item.authorDetails.displayName;
        const message = item.snippet.displayMessage;
        spawnOrUpdate(username, message);
      });
    }

    setTimeout(fetchChat, 1500); // Poll chat every 1.5 seconds

  } catch (err) {
    console.error('YT chat error:', err);
    setTimeout(fetchChat, 5000);
  }
}

fetchChat();
</script>
</body>
</html>

